{"version":3,"sources":["paginator.js"],"names":["debounce","fn","duration","debounceHandle","args","Array","prototype","slice","call","arguments","clearTimeout","setTimeout","apply","toAttrSelector","key","value","toClassSelector","classString","split","filter","string","trim","length","join","PaginatorOptions","rawOpts","PaginatorContainer","klass","opts","createElement","self","$el","$","addClass","$margin","marginClass","append","page","this","clear","html","mountTo","parent","getBlocks","children","PaginatorPage","pageClass","header","content","footer","getContentHeight","$header","$footer","topHeight","Math","max","height","parseInt","css","bottomHeight","getContentLowerBoundary","paginator","headerClass","mainClass","footerClass","hasBreaks","getOverflowBlocks","isBlank","$block","position","top","unmount","remove","view","PaginatorRenderer","writePageComponents","pages","forEach","i","writeToBlockContainer","isContentClassRepetitive","getContentContainer","firstPage","getAllocationKey","getAllocationValue","allocateSpaceForContent","resetToDefaultMargins","resetMarginsOfAllPages","labelControlElements","index","find","controlElsSelector","focusableElsSelector","each","j","attr","idAttrName","blocks","contentContainer","headerFooterIndex","model","getIndexForPage","isRepetitive","lastFocusedElementId","document","activeElement","$renderedBlock","clone","parents","is","pageDeletedClass","off","$blockParent","blockParentClass","orderDataAttrName","data","parentDataAttrName","removeClass","pageBlockClass","pageAddedClass","on","$this","console","log","e","which","d","$origEl","removeAttr","val","trigger","type","$lastFocusedEl","focus","setOrder","checkDeletedBlocks","isParentDeleted","hasClass","insertPageForContent","newPage","pageIndex","addPage","getFirstPageWithBreak","pageToBreak","performPageBreaks","removeBlankPages","pagesToDelete","push","reverse","pageNumber","splice","orderContent","sortElements","block1","block2","order1","order2","keepFirstPage","doWriting","hasPerformedPageBreaks","lock","isRendering","detachObserver","attachObserver","render","doRender","imagesLoaded","always","PaginatorModel","modelClass","$watch","watchClass","getBlockContainers","isTerminal","terminalClass","getCount","getIndexForTerminalBlockContainer","count","pageCount","getPageCount","lastIndex","$blocks","k","eq","hasTerminalBlockContainer","$blockContainer","getOrderedBlocks","PaginatorView","viewClass","addToPageList","isNaN","Paginator","renderer","commitMutations","mutations","firstMutation","target","attributeName","debouncedRender","bindToElement","componentClass","unpaginatedClass","createModel","$modelChildren","createView","createRenderer","observeModel","isObserving","observeModelEvents","areEventsAttached","attachEventListeners","doObserve","doRefresh","pub","modelObserver","MutationObserver","debounceDuration","disconnect","observe","childList","attributes","characterData","subtree","refresh","jQuery","findShallow","sel","root","matching","first","sort","comparator","getSortable","placements","map","sortElement","parentNode","nextSibling","insertBefore","createTextNode","Error","removeChild","paginate"],"mappings":"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","file":"jquery-paginator.min.js","sourcesContent":["(function () {\n    var componentClass = 'paginator-component',\n        unpaginatedClass = 'paginator-unpaginated',\n        modelClass = 'model',\n        viewClass = 'view',\n        watchClass = 'watch',\n        pageClass = 'page',\n        pageBlockClass = 'page-block',\n        pageAddedClass = 'page-added',\n        pageDeletedClass = 'page-deleted',\n        mainClass = 'content',\n        headerClass = 'header',\n        footerClass = 'footer',\n        marginClass = 'margin',\n        parentDataAttrName = 'parent',\n        terminalClass = '-terminal',\n        blockParentClass = 'block-parent',\n        orderDataAttrName = 'data-order',\n        idAttrName = 'data-element-id',\n        controlElsSelector = 'input, select, textarea, button, a, meter',\n        focusableElsSelector = '[tabindex=\"0\"]',\n        debounceDuration = 250;\n\n    // http://stackoverflow.com/questions/7051897/how-can-i-select-the-shallowest-matching-descendant\n    jQuery.fn.findShallow = function(sel) {\n        return (function findShallow(root, sel) {\n            var children = root.children();\n            if (children.length) {\n                var matching = children.filter(sel);\n                if (matching.length) {\n                    return matching.first();\n                }\n                return findShallow(children, sel);\n            }\n            return $();\n        })(this, sel);\n    };\n\n    // http://james.padolsey.com/snippets/sorting-elements-with-jquery/\n    jQuery.fn.sortElements = (function () {\n        var sort = [].sort;\n\n        return function (comparator, getSortable) {\n\n            getSortable = getSortable || function () { return this; };\n\n            var placements = this.map(function () {\n\n                var sortElement = getSortable.call(this),\n                    parentNode = sortElement.parentNode,\n\n                // Since the element itself will change position, we have\n                // to have some way of storing its original position in\n                // the DOM. The easiest way is to have a 'flag' node:\n                    nextSibling = parentNode.insertBefore(\n                        document.createTextNode(''),\n                        sortElement.nextSibling\n                    );\n\n                return function () {\n\n                    if (parentNode === this) {\n                        throw new Error(\n                            \"You can't sort elements if any one is a descendant of another.\"\n                        );\n                    }\n\n                    // Insert before flag:\n                    parentNode.insertBefore(this, nextSibling);\n                    // Remove flag:\n                    parentNode.removeChild(nextSibling);\n\n                };\n\n            });\n\n            return sort.call(this, comparator).each(function (i) {\n                placements[i].call(getSortable.call(this));\n            });\n\n        };\n    })();\n\n    /**\n     * Creates a debounced version of a function\n     * @param {function} fn The function\n     * @param {number} duration The debounce duration.\n     * @returns {function} The debounced version of the function.\n     */\n    function debounce(fn, duration) {\n        var debounceHandle = null;\n\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n\n            if (!!debounceHandle) {\n                clearTimeout(debounceHandle);\n            }\n\n            debounceHandle = setTimeout(function () {\n                fn.apply(null, args);\n            }, duration);\n        };\n    }\n\n    /**\n     * Converts a data attribute key/value pair to its corresponding CSS selector.\n     * @param key The attribute key.\n     * @param value The attribute value.\n     * @returns {string} The selector string.\n     */\n    function toAttrSelector(key, value) {\n        return '[' + key + '=\"' + value + '\"]';\n    }\n\n    /**\n     * Converts a class string to a CSS selector.\n     * @param {string} classString The class string.\n     * @returns {string} The selector string.\n     */\n    function toClassSelector(classString) {\n        return '.' + classString.split(' ').filter(function (string) { return string.trim().length > 0 }).join('.');\n    }\n\n    /**\n     * Class for the options for the paginator.\n     * @param {object} rawOpts The raw options data.\n     * @constructor\n     */\n    function PaginatorOptions(rawOpts) {\n        return rawOpts;\n    }\n\n    /**\n     * Class for the container of contents on a page.\n     * @param {string} klass The class name of the main HTML element generated by the component.\n     * @param {PaginatorOptions} opts The options of the paginator.\n     * @constructor\n     */\n    function PaginatorContainer(klass, opts) {\n        var self = this,\n            page;\n\n        /**\n         * Creates the elements of the component.\n         */\n        function createElement() {\n            self.$el = self.$el || $('<div>').addClass(klass);\n            self.$margin = self.$margin = $('<div>').addClass(marginClass);\n\n            self.$el.append(self.$margin);\n        }\n\n        /**\n         * Appends a content to this component.\n         * @param {jQuery} $el The element to append.\n         */\n        self.append = function append($el) {\n            self.$margin.append($el);\n        };\n\n        /**\n         * Clears the page content.\n         */\n        self.clear = function clear() {\n            self.$margin.html('');\n        };\n\n        /**\n         * Mounts this component to a parent component.\n         * @param {object} parent The parent component.\n         */\n        self.mountTo = function mountTo(parent) {\n            if (page === parent) {\n                return;\n            }\n\n            page = parent;\n            page.$el.append(self.$el);\n        };\n\n        /**\n         * Gets the content blocks of this component.\n         * @returns {jQuery} The content blocks of this component.\n         */\n        self.getBlocks = function getBlocks() {\n            return self.$margin.children();\n        };\n\n        createElement();\n    }\n\n    /**\n     * Class for the page that is to be rendered in the paginator.\n     * @param {PaginatorOptions} opts The options of the paginator.\n     * @constructor\n     */\n    function PaginatorPage(opts) {\n        var self = this,\n            paginator;\n\n        self.header = new PaginatorContainer(headerClass, opts);\n        self.content = new PaginatorContainer(mainClass, opts);\n        self.footer = new PaginatorContainer(footerClass, opts);\n\n        /**\n         * Creates the elements of the component.\n         */\n        function createElement() {\n            self.$el = self.$el || $('<div>').addClass(pageClass);\n            self.$el\n                .append(self.header.$el)\n                .append(self.content.$el)\n                .append(self.footer.$el);\n        }\n\n        /**\n         * Gets the content height of the page.\n         * @returns {number} The content height of the page.\n         */\n        function getContentHeight() {\n            var $header = self.header.$el,\n                $footer = self.footer.$el,\n                $margin = self.content.$margin,\n                topHeight = Math.max($header.length > 0 ? $header.height() : 0, parseInt($margin.css('margin-top'))),\n                bottomHeight = Math.max($footer.length > 0 ? $footer.height() : 0, parseInt($margin.css('margin-bottom')));\n\n            return self.$el.height() - topHeight - bottomHeight;\n        }\n\n        /**\n         * Gets the current page index.\n         * @returns {number} The current page index.\n         */\n        function getPageIndex() {\n            var pageIndex = -1;\n\n            paginator.pages.forEach(function (page, i) {\n                if (page !== self) {\n                    return;\n                }\n\n                pageIndex = i;\n            });\n\n            return pageIndex;\n        }\n\n        /**\n         * Gets the lower boundary of the page.\n         * @returns {number} The lower boundary of the page.\n         */\n        function getContentLowerBoundary() {\n            var $header = self.header.$el,\n                $margin = self.content.$margin,\n                topHeight = Math.max($header.length > 0 ? $header.height() : 0, parseInt($margin.css('margin-top')));\n            return topHeight + getContentHeight();\n        }\n\n        /**\n         * Determines if the page has elements that can trigger page breaks.\n         * @returns {boolean} Does the page require breaks?\n         */\n        self.hasBreaks = function hasBreaks() {\n            return self.getOverflowBlocks().length > 0;\n        };\n\n        /**\n         * Determines if the page is blank (no blocks currently written).\n         * @returns {boolean} Is the page blank?\n         */\n        self.isBlank = function isBlank() {\n            return self.content.$margin.children().length < 1;\n        };\n\n        /**\n         * Gets the elements that overflow the content area of the page.\n         * @returns {jQuery} The elements.\n         */\n        self.getOverflowBlocks = function getOverflowBlocks() {\n            return self.content.getBlocks()\n                .filter(function () {\n                    var $block = $(this),\n                        position = $block.position().top,\n                        height = $block.height();\n\n                    return position + height > getContentLowerBoundary();\n                });\n        };\n\n        /**\n         * Unmounts the page.\n         */\n        self.unmount = function unmount() {\n            self.$el.remove();\n        };\n\n        /**\n         * Mounts the component to a parent.\n         * @param {object} parent The component\n         */\n        self.mountTo = function mountTo(parent) {\n            if (paginator === parent) {\n                return;\n            }\n\n            paginator = parent;\n            paginator.view.$el.append(self.$el);\n        };\n\n        createElement();\n    }\n\n    /**\n     * Class for the renderer of the paginator.\n     * @param {PaginatorOptions} opts\n     * @constructor\n     */\n    function PaginatorRenderer(opts) {\n        var self = this,\n            model,\n            view,\n            paginator,\n            firstPage = new PaginatorPage(opts),\n            isRendering = false,\n            lastFocusedElementId,\n            $lastFocusedEl = [];\n\n        /**\n         * Writes the appropriate headers and the footers of the page.\n         */\n        function writePageComponents() {\n            paginator.pages.forEach(function (page, i) {\n                writeToBlockContainer(headerClass, page, i);\n                writeToBlockContainer(footerClass, page, i);\n            });\n        }\n\n        /**\n         * Determines if the content class is repetitive.\n         * @param klass The content class.\n         * @returns {boolean} Is the content class repetitive among pages?\n         */\n        function isContentClassRepetitive(klass) {\n            return klass === headerClass || klass === footerClass;\n        }\n\n        /**\n         * Gets a page's content container of a content class.\n         * @param {PaginatorPage} page The page.\n         * @param {string} klass The content class.\n         * @returns {PaginatorContainer} The content container.\n         */\n        function getContentContainer(page, klass) {\n            if (klass === mainClass) {\n                return firstPage.content;\n            }\n\n            return page[klass];\n        }\n\n        /**\n         * Gets the CSS key of the page to allocate space for the content class.\n         * @param klass The content class.\n         * @returns {string|null} The CSS key.\n         */\n        function getAllocationKey(klass) {\n            switch (klass) {\n                case headerClass:\n                    return 'margin-top';\n                case footerClass:\n                    return 'margin-bottom';\n                default:\n                    break;\n            }\n\n            return null;\n        }\n\n        /**\n         * Gets the allocation size of a page's content class.\n         * @param {PaginatorPage} page The page.\n         * @param {string} klass The content class.\n         * @returns {number} The margin value, in pixels.\n         */\n        function getAllocationValue(page, klass) {\n            if (klass === headerClass || klass === footerClass) {\n                return getContentContainer(page, klass).$el.height();\n            }\n            return 0;\n        }\n\n        /**\n         * Allocate page space for the content of the content class.\n         * @param {PaginatorPage} page The page.\n         * @param {string} klass The content class.\n         */\n        function allocateSpaceForContent(page, klass) {\n            var key = getAllocationKey(klass),\n                value;\n\n            if (!key) {\n                return;\n            }\n\n            value = getAllocationValue(page, klass);\n            page.content.$margin.css(key, value);\n        }\n\n        /**\n         * Reset default margins for the page.\n         * @param {PaginatorPage} page\n         * @param {string} klass\n         */\n        function resetToDefaultMargins(page, klass) {\n            var key;\n\n            if (!page) {\n                return;\n            }\n\n            key = getAllocationKey(klass);\n\n            page.content.$margin.css(key, null);\n        }\n\n        /**\n         *\n         */\n        function resetMarginsOfAllPages() {\n            paginator.pages.forEach(function (page) {\n                resetToDefaultMargins(page, headerClass);\n                resetToDefaultMargins(page, footerClass);\n            });\n        }\n\n        /**\n         * Labels the control elements of the block, to be used for synchronizing\n         * the data and attributes of the controls.\n         * @param {Element} $block The block.\n         * @param {number} index The index of the block.\n         */\n        function labelControlElements($block, index) {\n            $block\n                .find(controlElsSelector + ', ' + focusableElsSelector)\n                .each(function (j) {\n                    $(this).attr(idAttrName, '' + index + '.' + j);\n                });\n        }\n\n        /**\n         * Writes the content of the page.\n         */\n        function writeToBlockContainer(klass, page, i) {\n            var headerFooterIndex = model.getIndexForPage(klass, i),\n                blocks,\n                isRepetitive = isContentClassRepetitive(klass),\n                contentContainer;\n\n            contentContainer = getContentContainer(page, klass);\n\n            if (!contentContainer) {\n                // No content container to put the content blocks to\n                return;\n            }\n\n            if (isRepetitive) {\n                // Clear repetitive content because\n                // we can clone them again.\n                contentContainer.clear();\n            }\n\n            if (headerFooterIndex < 0) {\n                // No header/footer in this page.\n                return;\n            }\n\n            blocks = model.getBlocks(klass);\n\n            if (isRepetitive) {\n                // get appropriate header/footer index for this page\n                blocks = blocks(headerFooterIndex);\n            }\n\n            lastFocusedElementId = $(document.activeElement).attr(idAttrName) || lastFocusedElementId;\n\n            blocks\n                .each(function (i) {\n                    var $block = $(this),\n                        $renderedBlock = $block;\n\n                    labelControlElements($block, i);\n\n                    if (isRepetitive) {\n                        $renderedBlock = $block.clone(true, true);\n                    }\n\n                    if (!$block.parents().is('body') || $block.parents(toClassSelector(pageDeletedClass)).length > 0) {\n                        // block is detached and not visible, or is deleted.\n                        $renderedBlock.off('change', controlElsSelector);\n                        return;\n                    }\n\n                    $blockParent = $block.parent();\n\n                    $blockParent\n                        .addClass(blockParentClass)\n                        .attr(orderDataAttrName, 0);\n\n                    $renderedBlock\n                        .attr(idAttrName, i)\n                        .data(parentDataAttrName, $blockParent)\n                        .removeClass(pageBlockClass)\n                        .addClass(pageAddedClass)\n                        .on('click', focusableElsSelector, function () {\n                            var $this = $(this);\n\n                            console.log($this);\n                        })\n                        .on('keypress', focusableElsSelector, function (e) {\n                            var $this = $(this);\n\n                            if (e.which === 13) {\n                                console.log($this, 'keypress');\n                            }\n                        })\n                        .on('change', controlElsSelector, function (e, d) {\n                            var $origEl,\n                                $this = $(this);\n\n                            if (!isRepetitive) {\n                                return;\n                            }\n\n                            lastFocusedElementId = $this.attr(idAttrName);\n                            $origEl = $blockParent.find(toAttrSelector(idAttrName, lastFocusedElementId));\n\n                            if ($this.is('select')) {\n                                $origEl\n                                    .find('option')\n                                    .removeAttr('selected')\n                                    .filter(toAttrSelector('value', $this.val()))\n                                    .attr('selected', 'selected');\n                            }\n\n                            $origEl\n                                .val($this.val())\n                                .trigger(e.type, d);\n                        });\n\n                    contentContainer.append($renderedBlock);\n                });\n\n            contentContainer.getBlocks().length > 0 ? allocateSpaceForContent(page, klass) : resetToDefaultMargins(page, klass);\n\n            $lastFocusedEl = contentContainer.$el.find(toAttrSelector(idAttrName, lastFocusedElementId));\n\n            if ($lastFocusedEl.length > 0) {\n                $lastFocusedEl[0].focus();\n            }\n        }\n\n        /**\n         * Sets the ordering of each block rendered in the view.\n         */\n        function setOrder() {\n            model.$el\n                .find(toClassSelector(blockParentClass))\n                .each(function (i) {\n                    $(this).attr(orderDataAttrName, i);\n                });\n\n            view.getBlocks('content')\n                .each(function () {\n                    var $block = $(this),\n                        $blockParent = $block.data(parentDataAttrName);\n\n                    $block.attr(orderDataAttrName, $blockParent.attr(orderDataAttrName));\n                });\n        }\n\n        /**\n         * Checks the view for deleted blocks and performs the appropriate actions.\n         */\n        function checkDeletedBlocks() {\n            view\n                .getBlocks('content')\n                .each(function () {\n                    var $block = $(this),\n                        $blockParent,\n                        isParentDeleted;\n\n                    $blockParent = $block.data(parentDataAttrName);\n\n                    isParentDeleted = !$blockParent ||\n                            $blockParent.hasClass(pageDeletedClass) ||\n                            $blockParent.parents(toClassSelector(pageDeletedClass)).length > 0 ||\n                            !$blockParent.parents().is('body');\n\n                    if (!isParentDeleted) {\n                        return;\n                    }\n\n                    $block.remove();\n                });\n        }\n\n        /**\n         * Inserts a page for new content.\n         * @param {{blocks:jQuery,pageIndex:number}} content The content.\n         */\n        function insertPageForContent(content) {\n            var newPage = new PaginatorPage(opts);\n\n            content.blocks.each(function () {\n                newPage.content.append($(this));\n            });\n\n            paginator.pages.slice(content.pageIndex + 1).forEach(function (page) {\n                newPage.content.append(page.content.getBlocks());\n            });\n\n            view.addPage(newPage);\n        }\n\n        /**\n         * Gets the content of the first page that has a break.\n         * @returns {{blocks:jQuery,pageIndex:number}} The content to insert.\n         */\n        function getFirstPageWithBreak() {\n            var pageToBreak = null;\n\n            paginator.pages.forEach(function (page, i) {\n                if (!page.hasBreaks() || pageToBreak !== null) {\n                    return;\n                }\n\n                // Get the first page to have page breaks.\n                pageToBreak = {\n                    pageIndex: i,\n                    blocks: page.getOverflowBlocks()\n                };\n            });\n\n            return pageToBreak;\n        }\n\n        /**\n         * Performs page breaks among the view's pages.\n         * @returns {boolean} A value that determines if the renderer performed page breaks, which is used to repeat this method.\n         */\n        function performPageBreaks() {\n            var pageToBreak = getFirstPageWithBreak();\n\n            if (pageToBreak === null) {\n                return false;\n            }\n\n            insertPageForContent(pageToBreak);\n            return true;\n        }\n\n        /**\n         *\n         */\n        function removeBlankPages() {\n            var pagesToDelete = [];\n\n            paginator.pages.forEach(function (page, i) {\n                if (!page.isBlank()) {\n                    return;\n                }\n                pagesToDelete.push(i);\n            });\n\n            pagesToDelete\n                .reverse()\n                .forEach(function (pageNumber) {\n                    if (paginator.pages.length < 2) {\n                        return;\n                    }\n                    paginator.pages[pageNumber].unmount();\n                    paginator.pages.splice(pageNumber, 1);\n                });\n        }\n\n        /**\n         *\n         */\n        function orderContent() {\n            view\n                .$el\n                .find('.content')\n                .find('.margin')\n                .children()\n                .sortElements(function (block1, block2) {\n                    var order1 = parseInt($(block1).attr(orderDataAttrName)),\n                        order2 = parseInt($(block2).attr(orderDataAttrName));\n\n                    return order1 - order2;\n                });\n        }\n\n        /**\n         * Adds the first page if it does not exist.\n         */\n        function keepFirstPage() {\n            if (paginator.pages.length > 0) {\n                return;\n            }\n            view.addPage(firstPage);\n        }\n\n        /**\n         * Writes the contents to the pages.\n         */\n        function doWriting() {\n            var hasPerformedPageBreaks;\n            do {\n                hasPerformedPageBreaks = performPageBreaks();\n                writePageComponents();\n            } while (hasPerformedPageBreaks);\n        }\n\n        /**\n         * Simulates a lock so that the renderer will not run multiple times.\n         * @param {function} fn The function to run.\n         */\n        function lock(fn) {\n            if (isRendering) {\n                return;\n            }\n\n            paginator.detachObserver();\n            isRendering = true;\n\n            fn();\n\n            paginator.attachObserver();\n            isRendering = false;\n        }\n\n        /**\n         * Renders the content.\n         */\n        self.render = function render() {\n            function doRender() {\n                keepFirstPage();\n                checkDeletedBlocks();\n                // TODO implement hard page/section breaks\n                // section breaks are what reset the header indexing, etc.\n                // TODO move elements when extra space has been found on previous pages.\n                resetMarginsOfAllPages();\n                writeToBlockContainer(mainClass);\n                setOrder();\n                orderContent();\n                doWriting();\n                removeBlankPages();\n                doWriting();\n            }\n\n            lock(function () {\n                paginator.$el.trigger('paginator.renderstart');\n                doRender();\n                paginator.$el.imagesLoaded().always(function () {\n                    doRender();\n                    paginator.$el.trigger('paginator.renderend');\n                });\n            });\n        };\n\n        /**\n         * Mounts the renderer to the paginator.\n         * @param {Paginator} parent The paginator.\n         */\n        self.mountTo = function mountTo(parent) {\n            paginator = parent;\n            model = paginator.model;\n            view = paginator.view;\n        };\n    }\n\n    /**\n     * Class for the model of the paginator.\n     * @param {PaginatorOptions} opts The options of the paginator.\n     * @constructor\n     */\n    function PaginatorModel(opts) {\n        var self = this,\n            paginator;\n\n        /**\n         * Creates the model element.\n         */\n        function createElement() {\n            self.$el = self.$el || $('<div>').addClass(modelClass);\n            if (!!self.$watch) {\n                return;\n            }\n            self.$watch = self.$watch || $('<div>').addClass(watchClass);\n            self.$el.append(self.$watch);\n        }\n\n        /**\n         *\n         * @param klass\n         * @param isTerminal\n         * @returns {*}\n         */\n        function getBlockContainers(klass, isTerminal) {\n            return self.$watch.find(toClassSelector(!!isTerminal ? klass + ' ' + terminalClass : klass));\n        }\n\n        /**\n         *\n         * @param klass\n         * @returns {*}\n         */\n        function getCount(klass) {\n            return getBlockContainers(klass).length;\n        }\n\n        /**\n         *\n         * @param klass\n         * @param pageNumber\n         * @returns {number}\n         */\n        function getIndexForTerminalBlockContainer(klass, pageNumber) {\n            var i,\n                count = getCount(klass),\n                index = -1,\n                pageCount = paginator.view.getPageCount(),\n                lastIndex = pageCount - 1,\n                $blocks = getBlockContainers(klass);\n\n            if (count === 1) {\n                switch (klass) {\n                    case headerClass:\n                        return pageNumber === 0 ? 0 : -1;\n                    case footerClass:\n                        return pageNumber === lastIndex ? 0 : -1;\n                    default:\n                        break;\n                }\n            }\n\n            i = 0;\n            do {\n                index = (index + 1) % count;\n                if (pageNumber === 0 && klass === headerClass ||\n                    pageNumber === lastIndex && klass === footerClass) {\n                    $blocks.each(function (k) {\n                        if (!$(this).hasClass(terminalClass)) {\n                            return;\n                        }\n                        index = k;\n                    });\n                    return index;\n                }\n\n                if ($blocks.eq(index).hasClass(terminalClass)) {\n                    index++;\n                }\n\n                i++;\n            } while (i < pageNumber);\n\n            return index;\n        }\n\n        /**\n         *\n         * @param klass\n         * @returns {boolean}\n         */\n        self.hasTerminalBlockContainer = function hasTerminalBlockContainer(klass) {\n            return getBlockContainers(klass, true).length > 0;\n        };\n\n        /**\n         *\n         * @param klass\n         * @param pageNumber\n         * @returns {*}\n         */\n        self.getIndexForPage = function getIndexForPage(klass, pageNumber) {\n            if (!self.hasTerminalBlockContainer(klass)) {\n                return pageNumber % getCount(klass);\n            }\n\n            return getIndexForTerminalBlockContainer(klass, pageNumber);\n        };\n\n        /**\n         *\n         * @param klass\n         * @returns {*}\n         */\n        self.getBlocks = function getBlocks(klass) {\n            switch (klass) {\n                case headerClass:\n                case footerClass:\n                    return function (i) {\n                        var $blockContainer = getBlockContainers(klass).eq(i),\n\n                            isTerminal = $blockContainer.hasClass(terminalClass),\n                            $blocks = $blockContainer.find(toClassSelector(pageBlockClass));\n\n                        return isTerminal ?\n                            $blocks.addClass(terminalClass) :\n                            $blocks.removeClass(terminalClass);\n                    };\n                default:\n                    break;\n            }\n\n            return getBlockContainers(klass).find(toClassSelector(pageBlockClass));\n        };\n\n        /**\n         *\n         * @param klass\n         * @returns {jQuery}\n         */\n        self.getOrderedBlocks = function getOrderedBlocks(klass) {\n            return getBlockContainers(klass).find('[' + orderDataAttrName + ']');\n        };\n\n        /**\n         *\n         * @param parent\n         */\n        self.mountTo = function mountTo(parent) {\n            if (paginator === parent) {\n                return;\n            }\n\n            paginator = parent;\n            paginator.$el.append(self.$el);\n        };\n\n        createElement();\n    }\n\n    /**\n     * Class for the view of the paginator.\n     * @param {PaginatorOptions} opts The options of the paginator.\n     * @constructor\n     */\n    function PaginatorView(opts) {\n        var self = this;\n\n        self.paginator = null;\n\n        /**\n         *\n         */\n        function createElement() {\n            self.$el = self.$el || $('<div>').addClass(viewClass);\n        }\n\n        /**\n         *\n         * @param page\n         * @param i\n         */\n        function addToPageList(page, i) {\n            if (isNaN(i) || i === null) {\n                self.paginator.pages.push(page);\n                return;\n            }\n\n            self.paginator.pages.splice(i, 0, page);\n        }\n\n        /**\n         *\n         * @returns {Number}\n         */\n        self.getPageCount = function getPageCount() {\n            return self.paginator.pages.length;\n        };\n\n        /**\n         *\n         * @param klass\n         * @returns {jQuery}\n         */\n        self.getBlocks = function getBlocks(klass) {\n            return self.$el\n                .find(toClassSelector(klass))\n                .children(toClassSelector(marginClass))\n                .children();\n        };\n\n        /**\n         *\n         * @param page\n         * @param i\n         * @returns {PaginatorPage}\n         */\n        self.addPage = function addPage(page, i) {\n            addToPageList(page, i);\n            page.mountTo(self.paginator);\n            return page;\n        };\n\n        /**\n         *\n         * @param parent\n         */\n        self.mountTo = function mountTo(parent) {\n            self.paginator = parent;\n            self.paginator.$el.append(self.$el);\n        };\n\n        createElement();\n    }\n\n    /**\n     * Class for the paginator.\n     * @param {Element} $el The element.\n     * @param {object} opts The options of the paginator.\n     * @constructor\n     */\n    function Paginator($el, opts) {\n        var self = this,\n            modelObserver = new MutationObserver(commitMutations),\n            pub,\n            areEventsAttached = false,\n            isObserving = false,\n            debouncedRender = debounce(render, debounceDuration);\n\n        opts = new PaginatorOptions(opts);\n\n        /**\n         *\n         * @type {PaginatorModel}\n         */\n        self.model = new PaginatorModel(opts);\n\n        /**\n         *\n         * @type {PaginatorView}\n         */\n        self.view = new PaginatorView(opts);\n\n        /**\n         *\n         * @type {PaginatorRenderer}\n         */\n        self.renderer = new PaginatorRenderer(opts);\n\n        /**\n         *\n         * @type {Array}\n         */\n        self.pages = self.pages || [];\n\n        /**\n         *\n         */\n        function render() {\n            self.renderer.render();\n        }\n\n        /**\n         *\n         * @param mutations\n         */\n        function commitMutations(mutations) {\n            var firstMutation = mutations[0];\n\n            if (firstMutation.target === self.model.$watch[0] &&\n                firstMutation.type === 'attributes' &&\n                firstMutation.attributeName === 'id') {\n                return;\n            }\n            debouncedRender();\n        }\n\n        /**\n         *\n         * @param $el\n         */\n        function bindToElement($el) {\n            if (!!self.$el) {\n                self.$el.removeClass(componentClass);\n            }\n            self.$el = $el;\n            if (self.$el.hasClass(componentClass)) {\n                return;\n            }\n            self.$el\n                .addClass(componentClass)\n                .removeClass(unpaginatedClass);\n        }\n\n        /**\n         *\n         */\n        function createModel() {\n            var $modelChildren;\n\n            self.model.mountTo(self);\n\n            $modelChildren = self\n                .$el\n                .find(\n                //.findShallow(\n                    [\n                        toClassSelector(headerClass),\n                        toClassSelector(mainClass),\n                        toClassSelector(footerClass)\n                    ]\n                        .join(',')\n                );\n\n            self.model.$watch.append($modelChildren);\n        }\n\n        /**\n         *\n         */\n        function createView() {\n            self.view.mountTo(self);\n        }\n\n        /**\n         *\n         */\n        function createRenderer() {\n            self.renderer.mountTo(self);\n        }\n\n        /**\n         *\n         */\n        self.detachObserver = function detachObserver() {\n            modelObserver.disconnect();\n        };\n\n        /**\n         *\n         */\n        self.attachObserver = function attachObserver() {\n            modelObserver\n                .observe(self.model.$watch[0], {\n                    childList: true,\n                    attributes: true,\n                    characterData: true,\n                    subtree: true\n                });\n        };\n\n        /**\n         *\n         */\n        self.attachEventListeners = function attachEventListeners() {\n            self.model.$watch\n                .on('change', controlElsSelector, function (e) {\n                    if (!isObserving) {\n                        return;\n                    }\n\n                    commitMutations([e]);\n                });\n        };\n\n        /**\n         *\n         */\n        function observeModel() {\n            if (!!isObserving) {\n                return;\n            }\n            self.attachObserver();\n            isObserving = true;\n        }\n\n        /**\n         *\n         */\n        function observeModelEvents() {\n            if (!!areEventsAttached) {\n                return;\n            }\n            self.attachEventListeners();\n            areEventsAttached = true;\n        }\n\n        /**\n         *\n         */\n        function doObserve() {\n            observeModel();\n            observeModelEvents();\n        }\n\n        /**\n         *\n         */\n        function doRefresh() {\n            render();\n        }\n\n        pub = (function PaginatorInstance() {\n            return {\n                observe: doObserve,\n                refresh: doRefresh\n            };\n        })();\n\n        bindToElement($el);\n        createModel();\n        createView();\n        createRenderer();\n        doObserve();\n        $el.data('paginator', pub);\n        return pub;\n    }\n\n    $.fn.paginate = function paginate(opts) {\n        return new Paginator(this, opts);\n    };\n})();\n"]}