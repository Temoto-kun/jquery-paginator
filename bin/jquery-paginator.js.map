{"version":3,"sources":["paginator.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"jquery-paginator.js","sourcesContent":["(function () {\n    var componentClass = 'paginator-component',\n        unpaginatedClass = 'paginator-unpaginated',\n        modelClass = 'model',\n        viewClass = 'view',\n        watchClass = 'watch',\n        pageClass = 'page',\n        pageBlockClass = 'page-block',\n        pageAddedClass = 'page-added',\n        pageDeletedClass = 'page-deleted',\n        contentClass = 'content',\n        headerClass = 'header',\n        footerClass = 'footer',\n        marginClass = 'margin',\n        parentDataAttrName = 'parent',\n        terminalClass = '-terminal',\n        blockParentClass = 'block-parent',\n        orderDataAttrName = 'data-order';\n\n    // http://stackoverflow.com/questions/7051897/how-can-i-select-the-shallowest-matching-descendant\n    jQuery.fn.findShallow = function(sel) {\n        return (function findShallow(root, sel) {\n            var children = root.children();\n            if (children.length) {\n                var matching = children.filter(sel);\n                if (matching.length) {\n                    return matching.first();\n                }\n                return findShallow(children, sel);\n            }\n            return $();\n        })(this, sel);\n    };\n\n    // http://james.padolsey.com/snippets/sorting-elements-with-jquery/\n    jQuery.fn.sortElements = (function () {\n        var sort = [].sort;\n\n        return function (comparator, getSortable) {\n\n            getSortable = getSortable || function () { return this; };\n\n            var placements = this.map(function () {\n\n                var sortElement = getSortable.call(this),\n                    parentNode = sortElement.parentNode,\n\n                // Since the element itself will change position, we have\n                // to have some way of storing its original position in\n                // the DOM. The easiest way is to have a 'flag' node:\n                    nextSibling = parentNode.insertBefore(\n                        document.createTextNode(''),\n                        sortElement.nextSibling\n                    );\n\n                return function () {\n\n                    if (parentNode === this) {\n                        throw new Error(\n                            \"You can't sort elements if any one is a descendant of another.\"\n                        );\n                    }\n\n                    // Insert before flag:\n                    parentNode.insertBefore(this, nextSibling);\n                    // Remove flag:\n                    parentNode.removeChild(nextSibling);\n\n                };\n\n            });\n\n            return sort.call(this, comparator).each(function (i) {\n                placements[i].call(getSortable.call(this));\n            });\n\n        };\n\n    })();\n\n    /**\n     * Converts a class string to a CSS selector.\n     * @param {string} classString The class string.\n     * @returns {string} The selector string.\n     */\n    function toClassSelector(classString) {\n        return '.' + classString.split(' ').filter(function (string) { return string.trim().length > 0 }).join('.');\n    }\n\n    /**\n     * Class for the options for the paginator.\n     * @param {object} rawOpts The raw options data.\n     * @constructor\n     */\n    function PaginatorOptions(rawOpts) {\n        return rawOpts;\n    }\n\n    /**\n     * Class for the container of contents on a page.\n     * @param {string} klass The class name of the main HTML element generated by the component.\n     * @param {PaginatorOptions} opts The options of the paginator.\n     * @constructor\n     */\n    function PaginatorPageContent(klass, opts) {\n        var self = this,\n            page;\n\n        /**\n         * Creates the elements of the component.\n         */\n        function createElement() {\n            self.$el = self.$el || $('<div>').addClass(klass);\n            self.$margin = self.$margin = $('<div>').addClass(marginClass);\n\n            self.$el.append(self.$margin);\n        }\n\n        /**\n         * Appends a content to this component.\n         * @param {jQuery} $el The element to append.\n         */\n        self.append = function append($el) {\n            self.$margin.append($el);\n        };\n\n        /**\n         *\n         */\n        self.clear = function clear() {\n            self.$margin.html('');\n        };\n\n        /**\n         * Mounts this component to a parent component.\n         * @param {object} parent The parent component.\n         */\n        self.mountTo = function mountTo(parent) {\n            if (page === parent) {\n                return;\n            }\n\n            page = parent;\n            page.$el.append(self.$el);\n        };\n\n        /**\n         * Gets the content blocks of this component.\n         * @returns {jQuery} The content blocks of this component.\n         */\n        self.getBlocks = function getBlocks() {\n            return self.$margin.children();\n        };\n\n        createElement();\n    }\n\n    /**\n     * Class for the page that is to be rendered in the paginator.\n     * @param {PaginatorOptions} opts The options of the paginator.\n     * @constructor\n     */\n    function PaginatorPage(opts) {\n        var self = this,\n            paginator;\n\n        self.header = new PaginatorPageContent(headerClass, opts);\n        self.content = new PaginatorPageContent(contentClass, opts);\n        self.footer = new PaginatorPageContent(footerClass, opts);\n\n        /**\n         * Creates the elements of the component.\n         */\n        function createElement() {\n            self.$el = self.$el || $('<div>').addClass(pageClass);\n            self.$el\n                .append(self.header.$el)\n                .append(self.content.$el)\n                .append(self.footer.$el);\n        }\n\n        /**\n         * Gets the content height of the page.\n         * @returns {number} The content height of the page.\n         */\n        function getContentHeight() {\n            var $header = self.header.$el,\n                $footer = self.footer.$el,\n                $margin = self.content.$margin,\n                topHeight = Math.max($header.length > 0 ? $header.height() : 0, parseInt($margin.css('margin-top'))),\n                bottomHeight = Math.max($footer.length > 0 ? $footer.height() : 0, parseInt($margin.css('margin-bottom')));\n\n            return self.$el.height() - topHeight - bottomHeight;\n        }\n\n        function getPageIndex() {\n            var pageIndex = -1;\n\n            paginator.pages.forEach(function (page, i) {\n                if (page !== self) {\n                    return;\n                }\n\n                pageIndex = i;\n            });\n\n            return pageIndex;\n        }\n\n        /**\n         * Gets the lower boundary of the page.\n         * @returns {number} The lower boundary of the page.\n         */\n        function getContentLowerBoundary() {\n            var $header = self.header.$el,\n                $margin = self.content.$margin,\n                topHeight = Math.max($header.length > 0 ? $header.height() : 0, parseInt($margin.css('margin-top')));\n            return topHeight + getContentHeight();\n        }\n\n        /**\n         * Determines if the page has elements that can trigger page breaks.\n         * @returns {boolean}\n         */\n        self.hasBreaks = function hasBreaks() {\n            return self.getOverflowBlocks().length > 0;\n        };\n\n        self.isBlank = function isBlank() {\n            return self.content.$margin.children().length < 1;\n        };\n\n        /**\n         * Gets the elements that overflow the content area of the page.\n         * @returns {jQuery} The elements.\n         */\n        self.getOverflowBlocks = function getOverflowBlocks() {\n            return self.content.getBlocks()\n                .filter(function () {\n                    var $block = $(this),\n                        position = $block.position().top,\n                        height = $block.height();\n\n                    return position + height > getContentLowerBoundary();\n                });\n        };\n\n        self.unmount = function unmount() {\n            self.$el.remove();\n        };\n\n        /**\n         * Mounts the component to a parent.\n         * @param {object} parent The component\n         */\n        self.mountTo = function mountTo(parent) {\n            if (paginator === parent) {\n                return;\n            }\n\n            paginator = parent;\n            paginator.view.$el.append(self.$el);\n        };\n\n        createElement();\n    }\n\n    /**\n     * Class for the renderer of the paginator.\n     * @param {PaginatorOptions} opts\n     * @constructor\n     */\n    function PaginatorRenderer(opts) {\n        var self = this,\n            model,\n            view,\n            paginator,\n            firstPage = new PaginatorPage(opts),\n            isRendering = false;\n\n        /**\n         * Writes the appropriate headers and the footers of the page.\n         */\n        function writePageComponents() {\n            paginator.pages.forEach(function (page, i) {\n                writeToBlockContainer(headerClass, page, i);\n                writeToBlockContainer(footerClass, page, i);\n            });\n        }\n\n        /**\n         * Writes the content of the page.\n         */\n        function writeToBlockContainer(klass, page, i) {\n            var blockContainerIndex = model.getIndexForPage(klass, i),\n                blocks,\n                isClone = false;\n\n            // TODO refactor this part of the code.\n\n            if (blockContainerIndex < 0) {\n                switch (klass) {\n                    case headerClass:\n                        page.header.clear();\n                        return;\n                    case footerClass:\n                        page.footer.clear();\n                        return;\n                    default:\n                        break;\n                }\n                return;\n            }\n\n            switch (klass) {\n                case footerClass:\n                    page.footer.clear();\n                    blocks = model.getBlocks(klass)(blockContainerIndex);\n                    isClone = true;\n                    break;\n                case headerClass:\n                    page.header.clear();\n                    blocks = model.getBlocks(klass)(blockContainerIndex);\n                    isClone = true;\n                    break;\n                default:\n                    blocks = model.getBlocks(klass);\n                    break;\n            }\n\n            function addBlockEventListener($block) {\n                // TODO bind event listener once\n                $block\n                    .on('change', 'input, textarea, select', function (e) {\n                    });\n            }\n\n            blocks\n                .each(function () {\n                    var $block = $(this),\n                        $renderedBlock = $block;\n\n                    if (isClone) {\n                        $renderedBlock = $block.clone(true, true);\n                    }\n\n                    if ($block.parents(toClassSelector(pageDeletedClass)).length > 0) {\n                        return;\n                    }\n\n                    $blockParent = $block.parent();\n\n                    $blockParent\n                        .addClass(blockParentClass)\n                        .attr(orderDataAttrName, 0);\n\n                    $renderedBlock\n                        .data(parentDataAttrName, $blockParent)\n                        .removeClass(pageBlockClass)\n                        .addClass(pageAddedClass);\n\n                    switch (klass) {\n                        case headerClass:\n                            addBlockEventListener($renderedBlock);\n                            page.header.append($renderedBlock);\n                            return;\n                        case footerClass:\n                            addBlockEventListener($renderedBlock);\n                            page.footer.append($renderedBlock);\n                            return;\n                        default:\n                            break;\n                    }\n\n                    firstPage.content.append($renderedBlock);\n                });\n\n            switch (klass) {\n                case headerClass:\n                    page.content.$margin.css('margin-top', page.$el.find(toClassSelector(klass)).height());\n                    break;\n                case footerClass:\n                    page.content.$margin.css('margin-bottom', page.$el.find(toClassSelector(klass)).height());\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        /**\n         * Sets the ordering of each block rendered in the view.\n         */\n        function setOrder() {\n            model.$el\n                .find(toClassSelector(blockParentClass))\n                .each(function (i) {\n                    $(this).attr(orderDataAttrName, i);\n                });\n\n            view.getBlocks('content')\n                .each(function () {\n                    var $block = $(this),\n                        $blockParent = $block.data(parentDataAttrName);\n\n                    $block.attr(orderDataAttrName, $blockParent.attr(orderDataAttrName));\n                });\n        }\n\n        /**\n         * Checks the view for deleted blocks and performs the appropriate actions.\n         */\n        function checkDeletedBlocks() {\n            view\n                .getBlocks('content')\n                .each(function () {\n                    var $block = $(this),\n                        $blockParent,\n                        isParentDeleted;\n\n                    $blockParent = $block.data(parentDataAttrName);\n\n                    isParentDeleted = !$blockParent ||\n                            $blockParent.hasClass(pageDeletedClass) ||\n                            $blockParent.parents(toClassSelector(pageDeletedClass)).length > 0 ||\n                            !$blockParent.parents().is('body');\n\n                    if (!isParentDeleted) {\n                        return;\n                    }\n\n                    $block.remove();\n                });\n        }\n\n        /**\n         * Inserts a page for new content.\n         * @param {{blocks:jQuery,pageIndex:number}} content The content.\n         */\n        function insertPageForContent(content) {\n            var newPage = new PaginatorPage(opts);\n\n            content.blocks.each(function () {\n                newPage.content.append($(this));\n            });\n\n            paginator.pages.slice(content.pageIndex + 1).forEach(function (page) {\n                newPage.content.append(page.content.getBlocks());\n            });\n\n            view.addPage(newPage);\n        }\n\n        /**\n         * Gets the content of the first page that has a break.\n         * @returns {{blocks:jQuery,pageIndex:number}} The content to insert.\n         */\n        function getFirstPageWithBreak() {\n            var pageToBreak = null;\n\n            paginator.pages.forEach(function (page, i) {\n                if (!page.hasBreaks() || pageToBreak !== null) {\n                    return;\n                }\n\n                // Get the first page to have page breaks.\n                pageToBreak = {\n                    pageIndex: i,\n                    blocks: page.getOverflowBlocks()\n                };\n            });\n\n            return pageToBreak;\n        }\n\n        /**\n         * Performs page breaks among the view's pages.\n         * @returns {boolean} A value that determines if the renderer performed page breaks, which is used to repeat this method.\n         */\n        function performPageBreaks() {\n            var pageToBreak = getFirstPageWithBreak();\n\n            if (pageToBreak === null) {\n                return false;\n            }\n\n            insertPageForContent(pageToBreak);\n            return true;\n        }\n\n        function removeBlankPages() {\n            var pagesToDelete = [];\n\n            paginator.pages.forEach(function (page, i) {\n                if (!page.isBlank()) {\n                    return;\n                }\n                pagesToDelete.push(i);\n            });\n\n            pagesToDelete\n                .reverse()\n                .forEach(function (pageNumber) {\n                    if (paginator.pages.length < 2) {\n                        return;\n                    }\n                    paginator.pages[pageNumber].unmount();\n                    paginator.pages.splice(pageNumber, 1);\n                });\n        }\n\n        function orderContent() {\n            view\n                .$el\n                .find('.content')\n                .find('.margin')\n                .children()\n                .sortElements(function (block1, block2) {\n                    var order1 = parseInt($(block1).attr(orderDataAttrName)),\n                        order2 = parseInt($(block2).attr(orderDataAttrName));\n\n                    return order1 - order2;\n                });\n        }\n\n        /**\n         * Renders the content.\n         */\n        self.render = function render() {\n            paginator.detachObserver();\n            if (paginator.pages.length < 1) {\n                view.addPage(firstPage);\n            }\n\n            var hasPerformedPageBreaks;\n\n            checkDeletedBlocks();\n            // TODO implement hard page/section breaks\n            // section breaks are what reset the header indexing, etc.\n            // TODO move elements when extra space has been found on previous pages.\n            writeToBlockContainer(contentClass);\n            setOrder();\n            orderContent();\n            do {\n                hasPerformedPageBreaks = performPageBreaks();\n                writePageComponents();\n            } while (hasPerformedPageBreaks);\n            removeBlankPages();\n            do {\n                hasPerformedPageBreaks = performPageBreaks();\n                writePageComponents();\n            } while (hasPerformedPageBreaks);\n\n            setTimeout(function () {\n                paginator.attachObserver();\n                isRendering = false;\n            });\n        };\n\n        /**\n         *\n         * @param parent\n         */\n        self.mountTo = function mountTo(parent) {\n            paginator = parent;\n            model = paginator.model;\n            view = paginator.view;\n        };\n    }\n\n    /**\n     * Class for the model of the paginator.\n     * @param {PaginatorOptions} opts The options of the paginator.\n     * @constructor\n     */\n    function PaginatorModel(opts) {\n        var self = this,\n            paginator;\n\n        /**\n         *\n         */\n        function createElement() {\n            self.$el = self.$el || $('<div>').addClass(modelClass);\n            if (!!self.$watch) {\n                return;\n            }\n            self.$watch = self.$watch || $('<div>').addClass(watchClass);\n            self.$el.append(self.$watch);\n        }\n\n        /**\n         *\n         * @param klass\n         * @param isTerminal\n         * @returns {*}\n         */\n        function getBlockContainers(klass, isTerminal) {\n            return self.$watch.find(toClassSelector(!!isTerminal ? klass + ' ' + terminalClass : klass));\n        }\n\n        /**\n         *\n         * @param klass\n         * @returns {*}\n         */\n        function getCount(klass) {\n            return getBlockContainers(klass).length;\n        }\n\n        /**\n         *\n         * @param klass\n         * @param pageNumber\n         * @returns {number|*}\n         */\n        function getIndexForTerminalBlockContainer(klass, pageNumber) {\n            var i,\n                count = getCount(klass),\n                index = -1,\n                pageCount = paginator.view.getPageCount(),\n                lastIndex = pageCount - 1,\n                $blocks = getBlockContainers(klass);\n\n            if (count === 1) {\n                switch (klass) {\n                    case headerClass:\n                        return pageNumber === 0 ? 0 : -1;\n                    case footerClass:\n                        return pageNumber === lastIndex ? 0 : -1;\n                    default:\n                        break;\n                }\n            }\n\n            i = 0;\n            do {\n                index = (index + 1) % count;\n                if (pageNumber === 0 && klass === headerClass ||\n                    pageNumber === lastIndex && klass === footerClass) {\n                    $blocks.each(function (k) {\n                        if (!$(this).hasClass(terminalClass)) {\n                            return;\n                        }\n                        index = k;\n                    });\n                    return index;\n                }\n\n                if ($blocks.eq(index).hasClass(terminalClass)) {\n                    index++;\n                }\n\n                i++;\n            } while (i < pageNumber);\n\n            return index;\n        }\n\n        /**\n         *\n         * @param klass\n         * @returns {boolean}\n         */\n        self.hasTerminalBlockContainer = function hasTerminalBlockContainer(klass) {\n            return getBlockContainers(klass, true).length > 0;\n        };\n\n        /**\n         *\n         * @param klass\n         * @param pageNumber\n         * @returns {*}\n         */\n        self.getIndexForPage = function getIndexForPage(klass, pageNumber) {\n            if (!self.hasTerminalBlockContainer(klass)) {\n                return pageNumber % getCount(klass);\n            }\n\n            return getIndexForTerminalBlockContainer(klass, pageNumber);\n        };\n\n        /**\n         *\n         * @param klass\n         * @returns {*}\n         */\n        self.getBlocks = function getBlocks(klass) {\n            switch (klass) {\n                case headerClass:\n                case footerClass:\n                    return function (i) {\n                        var $blockContainer = getBlockContainers(klass).eq(i),\n\n                            isTerminal = $blockContainer.hasClass(terminalClass),\n                            $blocks = $blockContainer.find(toClassSelector(pageBlockClass));\n\n                        return isTerminal ?\n                            $blocks.addClass(terminalClass) :\n                            $blocks.removeClass(terminalClass);\n                    };\n                default:\n                    break;\n            }\n\n            return getBlockContainers(klass).find(toClassSelector(pageBlockClass));\n        };\n\n        /**\n         *\n         * @param klass\n         * @returns {*|{}}\n         */\n        self.getOrderedBlocks = function getOrderedBlocks(klass) {\n            return getBlockContainers(klass).find('[' + orderDataAttrName + ']');\n        };\n\n        /**\n         *\n         * @param parent\n         */\n        self.mountTo = function mountTo(parent) {\n            if (paginator === parent) {\n                return;\n            }\n\n            paginator = parent;\n            paginator.$el.append(self.$el);\n        };\n\n        createElement();\n    }\n\n    /**\n     * Class for the view of the paginator.\n     * @param {PaginatorOptions} opts The options of the paginator.\n     * @constructor\n     */\n    function PaginatorView(opts) {\n        var self = this;\n\n        self.paginator = null;\n\n        /**\n         *\n         */\n        function createElement() {\n            self.$el = self.$el || $('<div>').addClass(viewClass);\n        }\n\n        /**\n         *\n         * @param page\n         * @param i\n         */\n        function addToPageList(page, i) {\n            if (isNaN(i) || i === null) {\n                self.paginator.pages.push(page);\n                return;\n            }\n\n            self.paginator.pages.splice(i, 0, page);\n        }\n\n        /**\n         *\n         * @returns {Number}\n         */\n        self.getPageCount = function getPageCount() {\n            return self.paginator.pages.length;\n        };\n\n        /**\n         *\n         * @param klass\n         * @returns {XMLList}\n         */\n        self.getBlocks = function getBlocks(klass) {\n            return self.$el\n                .find(toClassSelector(klass))\n                .children(toClassSelector(marginClass))\n                .children();\n        };\n\n        /**\n         *\n         * @param page\n         * @param i\n         * @returns {*}\n         */\n        self.addPage = function addPage(page, i) {\n            addToPageList(page, i);\n            page.mountTo(self.paginator);\n            return page;\n        };\n\n        /**\n         *\n         * @param parent\n         */\n        self.mountTo = function mountTo(parent) {\n            self.paginator = parent;\n            self.paginator.$el.append(self.$el);\n        };\n\n        createElement();\n    }\n\n    /**\n     * Class for the paginator.\n     * @param {Element} $el The element.\n     * @param {object} opts The options of the paginator.\n     * @constructor\n     */\n    function Paginator($el, opts) {\n        var self = this,\n            modelObserver = new MutationObserver(commitMutations),\n            pub,\n            areEventsAttached = false,\n            isObserving = false,\n            debounceHandle = null;\n\n        opts = new PaginatorOptions(opts);\n\n        /**\n         *\n         * @type {PaginatorModel}\n         */\n        self.model = new PaginatorModel(opts);\n\n        /**\n         *\n         * @type {PaginatorView}\n         */\n        self.view = new PaginatorView(opts);\n\n        /**\n         *\n         * @type {PaginatorRenderer}\n         */\n        self.renderer = new PaginatorRenderer(opts);\n\n        /**\n         *\n         * @type {Array}\n         */\n        self.pages = self.pages || [];\n\n        /**\n         *\n         */\n        function render() {\n            self.renderer.render();\n        }\n\n        function commitMutations(mutations) {\n            var isHeaderFooterElement;\n\n            console.log(mutations);\n\n            //isHeaderFooterElement = mutations.reduce(function (isElement, mutation) {\n            //    var $parents = $(mutation.target).parents();\n            //\n            //    return isElement && (\n            //            $parents.is(toClassSelector(headerClass)) ||\n            //            $parents.is(toClassSelector(footerClass))\n            //        );\n            //}, true);\n\n            //if (isHeaderFooterElement) {\n            //    return;\n            //}\n\n            if (!!debounceHandle) {\n                clearTimeout(debounceHandle);\n            }\n\n            debounceHandle = setTimeout(function () {\n                render();\n            }, 250);\n        }\n\n        /**\n         *\n         * @param $el\n         */\n        function bindToElement($el) {\n            if (!!self.$el) {\n                self.$el.removeClass(componentClass);\n            }\n            self.$el = $el;\n            if (self.$el.hasClass(componentClass)) {\n                return;\n            }\n            self.$el\n                .addClass(componentClass)\n                .removeClass(unpaginatedClass);\n        }\n\n        /**\n         *\n         */\n        function createModel() {\n            var $modelChildren;\n\n            self.model.mountTo(self);\n\n            $modelChildren = self\n                .$el\n                .find(\n                //.findShallow(\n                    [\n                        toClassSelector(headerClass),\n                        toClassSelector(contentClass),\n                        toClassSelector(footerClass)\n                    ]\n                        .join(',')\n                );\n\n            self.model.$watch.append($modelChildren);\n        }\n\n        /**\n         *\n         */\n        function createView() {\n            self.view.mountTo(self);\n        }\n\n        /**\n         *\n         */\n        function createRenderer() {\n            self.renderer.mountTo(self);\n        }\n\n        /**\n         *\n         */\n        self.detachObserver = function detachObserver() {\n            modelObserver.disconnect();\n        };\n\n        /**\n         *\n         */\n        self.attachObserver = function attachObserver() {\n            modelObserver\n                .observe(self.model.$watch[0], {\n                    childList: true,\n                    attributes: true,\n                    characterData: true,\n                    subtree: true\n                });\n        };\n\n        /**\n         *\n         */\n        self.attachEventListeners = function attachEventListeners() {\n            console.log(self.model.$watch);\n            self.model.$watch\n                .on('change', 'input, select, textarea', function (e, d) {\n                    var mutation;\n\n                    console.log('asdfasdfasdfasdfasdf');\n\n                    if (!isObserving) {\n                        return;\n                    }\n\n                    mutation = e;\n                    mutation.data = d;\n\n                    commitMutations([mutation]);\n                });\n        };\n\n        /**\n         *\n         */\n        function observeModel() {\n            if (!!isObserving) {\n                return;\n            }\n            self.attachObserver();\n            isObserving = true;\n        }\n\n        /**\n         *\n         */\n        function observeModelEvents() {\n            if (!!areEventsAttached) {\n                return;\n            }\n            self.attachEventListeners();\n            areEventsAttached = true;\n        }\n\n        /**\n         *\n         */\n        function doObserve() {\n            observeModel();\n            observeModelEvents();\n        }\n\n        /**\n         *\n         */\n        function doRefresh() {\n            render();\n        }\n\n        pub = (function PaginatorInstance() {\n            return {\n                observe: doObserve,\n                refresh: doRefresh\n            };\n        })();\n\n        bindToElement($el);\n        createModel();\n        createView();\n        createRenderer();\n        doObserve();\n        $el.data('paginator', pub);\n        return pub;\n    }\n\n    $.fn.paginate = function paginate(opts) {\n        return new Paginator(this, opts);\n    };\n})();\n"]}